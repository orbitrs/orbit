name: Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+*'
  workflow_dispatch:
    inputs:
      publish-crate:
        description: 'Whether to publish to crates.io'
        required: false
        type: boolean
        default: false
      build-docs:
        description: 'Whether to build and publish documentation'
        required: false
        type: boolean
        default: false
      cross-platform-artifacts:
        description: 'Whether to build artifacts for multiple platforms'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read
  pull-requests: read
  id-token: write

jobs:
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.changelog.outputs.content }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get version
        id: version
        run: echo "version=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')" >> $GITHUB_OUTPUT
        
      - name: Extract Changelog
        id: changelog
        uses: ffurrer2/extract-release-notes@v1
        with:
          filename: CHANGELOG.md
        
  publish:
    name: Publish to crates.io
    runs-on: ubuntu-latest
    needs: prepare
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.publish-crate)
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Check if crate exists and handle publishing
        run: |
          CRATE_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].name')
          VERSION=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')
          
          # Check if the crate with this version already exists
          RESPONSE=$(curl -s "https://crates.io/api/v1/crates/$CRATE_NAME/$VERSION")
          if echo "$RESPONSE" | grep -q "\"version\""; then
            echo "::warning::Crate $CRATE_NAME version $VERSION already exists on crates.io. Skipping publish."
          else
            echo "Publishing $CRATE_NAME version $VERSION to crates.io..."
            cargo publish --token ${{ secrets.CRATES_TOKEN }}
          fi
        
  docs:
    name: Build & Publish Docs
    runs-on: ubuntu-latest
    needs: prepare
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.build-docs)
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Build documentation
        run: cargo doc --no-deps --document-private-items
      
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ github.token }}
          publish_dir: ./target/doc
          
  artifacts:
    name: Build Artifacts
    runs-on: ${{ matrix.os }}
    needs: prepare
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.cross-platform-artifacts)
    strategy:
      matrix:
        include:
          # Linux builds
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux-x86_64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            name: linux-aarch64
          
          # Windows builds
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows-x86_64
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            name: windows-aarch64
          
          # macOS builds
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macos-x86_64
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macos-aarch64
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
        
      - name: Install cross-compilation tools
        if: contains(matrix.target, 'aarch64')
        shell: bash
        run: |
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            # Setup for Linux ARM64 cross-compilation
            cargo install cross
            
            # Create Cross.toml configuration file for OpenSSL
            mkdir -p .cargo
            cat > Cross.toml << EOF
            [target.aarch64-unknown-linux-gnu]
            image = "ghcr.io/cross-rs/aarch64-unknown-linux-gnu:edge"
            
            [target.aarch64-unknown-linux-gnu.env]
            passthrough = [
              "RUST_BACKTRACE",
              "RUST_LOG",
              "TRAVIS",
              "OPENSSL_DIR",
              "OPENSSL_LIB_DIR",
              "OPENSSL_INCLUDE_DIR",
              "OPENSSL_STATIC"
            ]
            EOF
            
            # Configure cargo for OpenSSL static linking
            echo '[build.env]' > .cargo/config.toml
            echo 'OPENSSL_STATIC = "1"' >> .cargo/config.toml
            
            # Create a patched Cargo.toml for aarch64 build that disables reqwest
            cp Cargo.toml Cargo.toml.original
            # Use sed to modify the reqwest dependency to be an optional feature
            sed -i 's/^reqwest = { version = "0.11", features = \["json"\] }$/reqwest = { version = "0.11", features = ["json"], optional = true }/g' Cargo.toml
            # Add an http feature that includes reqwest
            if ! grep -q '\[features\]' Cargo.toml; then
              echo -e "\n[features]\nhttp = [\"dep:reqwest\"]" >> Cargo.toml
            else
              sed -i '/\[features\]/a http = [\"dep:reqwest\"]' Cargo.toml
            fi
            echo "Modified Cargo.toml for aarch64 build to make reqwest optional"
          elif [ "${{ matrix.os }}" = "macos-latest" ]; then
            echo "macOS runners on GitHub Actions have built-in support for ARM64"
          elif [ "${{ matrix.os }}" = "windows-latest" ]; then
            echo "Using MSVC cross-compiler for Windows ARM64"
          fi
        
      - name: Install system dependencies (Linux x86_64 only)
        if: matrix.os == 'ubuntu-latest' && !contains(matrix.target, 'aarch64')
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libfontconfig1-dev \
            libfreetype6-dev
          
      - name: Build release
        shell: bash
        run: |
          if [ "${{ matrix.target }}" = "aarch64-unknown-linux-gnu" ]; then
            # Skip dependencies that require OpenSSL in cross-compilation
            
            # Build with cross and disable problematic features
            cross build --release --target ${{ matrix.target }} \
              --no-default-features \
              --features="skia,gl" \
              --verbose
          else
            # Use standard cargo build for other targets
            cargo build --release --target ${{ matrix.target }}
          fi
          
      - name: Restore original Cargo.toml
        if: matrix.target == 'aarch64-unknown-linux-gnu' && matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          if [ -f "Cargo.toml.original" ]; then
            mv Cargo.toml.original Cargo.toml
            echo "Restored original Cargo.toml"
          fi
        
      - name: Package artifacts
        shell: bash
        run: |
          # First check if there are any binary targets
          BINARY_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].targets[] | select(.kind[] | contains("bin")) | .name' | head -n1)
          
          # Get package name for creating artifacts even if no binary targets exist
          PACKAGE_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].name')
          PACKAGE_VERSION=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')
          TARGET=${{ matrix.target }}
          OS_NAME=${{ matrix.name }}
          
          # Create a dist directory with the target platform in the name to avoid conflicts
          mkdir -p "dist/${OS_NAME}"
          
          # Create a manifest file with build information
          cat > "dist/${OS_NAME}/manifest.txt" << EOL
          Package: ${PACKAGE_NAME}
          Version: ${PACKAGE_VERSION}
          Target: ${TARGET}
          Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Git SHA: ${GITHUB_SHA}
          EOL
          
          if [ -n "$BINARY_NAME" ]; then
            # We have a binary target, copy it to dist with OS-specific name
            if [ "${{ matrix.os }}" = "windows-latest" ]; then
              cp "target/${TARGET}/release/${BINARY_NAME}.exe" "dist/${OS_NAME}/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.exe"
            else
              cp "target/${TARGET}/release/${BINARY_NAME}" "dist/${OS_NAME}/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}"
            fi
            echo "Binary target: ${BINARY_NAME}" >> "dist/${OS_NAME}/manifest.txt"
          else
            # No binary target found, create a package artifact instead
            echo "No binary target found. Creating package artifact for $PACKAGE_NAME v$PACKAGE_VERSION"
            echo "Library build - no binary targets found" >> "dist/${OS_NAME}/manifest.txt"
            
            # Create a directory for library files
            mkdir -p "dist/${OS_NAME}/lib"
            
            # Copy the compiled library artifacts if they exist with platform-specific names
            if [ -f "target/${TARGET}/release/lib${PACKAGE_NAME}.rlib" ]; then
              cp "target/${TARGET}/release/lib${PACKAGE_NAME}.rlib" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.rlib"
              echo "Library artifact: rlib" >> "dist/${OS_NAME}/manifest.txt"
            fi
            if [ -f "target/${TARGET}/release/lib${PACKAGE_NAME}.so" ]; then
              cp "target/${TARGET}/release/lib${PACKAGE_NAME}.so" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.so"
              echo "Library artifact: so" >> "dist/${OS_NAME}/manifest.txt"
            fi
            if [ -f "target/${TARGET}/release/lib${PACKAGE_NAME}.dylib" ]; then
              cp "target/${TARGET}/release/lib${PACKAGE_NAME}.dylib" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.dylib"
              echo "Library artifact: dylib" >> "dist/${OS_NAME}/manifest.txt"
            fi
            if [ -f "target/${TARGET}/release/${PACKAGE_NAME}.dll" ]; then
              cp "target/${TARGET}/release/${PACKAGE_NAME}.dll" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.dll"
              echo "Library artifact: dll" >> "dist/${OS_NAME}/manifest.txt"
            fi
          fi
          
          # Create a ZIP archive of the artifacts
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            powershell Compress-Archive -Path "dist/${OS_NAME}/*" -DestinationPath "dist/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.zip"
          else
            (cd "dist/${OS_NAME}" && zip -r "../${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.zip" .)
          fi
          
          # Keep both the directory and the ZIP file for flexibility
          echo "Created artifacts for ${PACKAGE_NAME} v${PACKAGE_VERSION} (${OS_NAME}):"
          find dist -type f | sort
      
      # Upload the zipped package directly
      - name: Upload zipped artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-zip
          path: dist/*.zip
          
      # Also upload the directory structure for compatibility
      - name: Upload directory artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-dir
          path: dist/${{ matrix.name }}/
  
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare, artifacts]
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.cross-platform-artifacts)
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
      
      - name: List artifacts structure
        run: |
          echo "Listing downloaded artifacts structure:"
          find dist -type f | sort
          
      - name: Prepare files for release
        run: |
          # Create a flat directory structure for the release
          mkdir -p release_files
          for file in $(find dist -type f); do
            # Extract just the filename without directory path
            filename=$(basename "$file")
            # Copy to release_files dir with unique names in case of conflicts
            dir_name=$(dirname "$file" | sed -e 's|dist/||' | tr '/' '-')
            if [ "$dir_name" = "." ]; then
              cp "$file" "release_files/$filename"
            else
              cp "$file" "release_files/${dir_name}-${filename}"
            fi
          done
          echo "Files prepared for release:"
          ls -la release_files/
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: v${{ needs.prepare.outputs.version }}
          body: ${{ needs.prepare.outputs.changelog }}
          files: |
            release_files/*
            dist/*.zip
          draft: false
          prerelease: false
          fail_on_unmatched_files: false
