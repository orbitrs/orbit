name: Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+*'
  workflow_dispatch:
    inputs:
      publish-crate:
        description: 'Publish to crates.io'
        type: boolean
        default: false
      build-docs:
        description: 'Build and publish documentation'
        type: boolean
        default: false
      cross-platform-artifacts:
        description: 'Build cross-platform artifacts'
        type: boolean
        default: false
      update-changelog:
        description: 'Update CHANGELOG.md from changelog.yaml before release'
        type: boolean
        default: true

permissions:
  contents: write
  actions: read
  pull-requests: read
  id-token: write

jobs:
  prepare:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.changelog.outputs.content }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get version
        id: version
        run: echo "version=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')" >> $GITHUB_OUTPUT
        
      - name: Update CHANGELOG.md if needed
        if: github.event.inputs.update-changelog == 'true'
        run: |
          VERSION=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')
          TODAY=$(date +"%Y-%m-%d")
          
          # Trigger the changelog workflow with the current version
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/changelog.yml/dispatches \
            -d "{\"ref\":\"${{ github.ref }}\", \"inputs\": {\"version\":\"$VERSION\", \"date\":\"$TODAY\"}}"
          
          # Give the workflow time to run and commit changes
          echo "Waiting for changelog workflow to complete..."
          sleep 30
          
          # Pull the latest changes including the updated CHANGELOG.md
          git pull
        
      - name: Extract Changelog
        id: changelog
        run: |
          # Extract the release notes for the current version from CHANGELOG.md
          VERSION=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')
          echo "Extracting changelog for version $VERSION"
          
          # Extract changelog section between the current version header and the next version header
          CHANGELOG=$(awk -v version="## \\[$VERSION\\]" '
            BEGIN { found=0; }
            /^## \[/ { 
              if (found == 1) { exit }
              if ($0 ~ version) { found=1; print; next } 
            }
            found { print }
          ' CHANGELOG.md)
          
          # Check if we found anything
          if [ -z "$CHANGELOG" ]; then
            echo "Version $VERSION not found in CHANGELOG.md"
            echo "content=No changelog entry found for version $VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Format for output
          CHANGELOG=$(echo "$CHANGELOG" | sed ':a;N;$!ba;s/\n/\\n/g')
          
          # Output the formatted changelog
          echo "content=$CHANGELOG" >> $GITHUB_OUTPUT
        
  publish:
    name: Publish to crates.io
    runs-on: ubuntu-latest
    needs: prepare
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.publish-crate)
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Check if crate exists and handle publishing
        run: |
          CRATE_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].name')
          VERSION=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')
          
          # Check if the crate with this version already exists
          RESPONSE=$(curl -s "https://crates.io/api/v1/crates/$CRATE_NAME/$VERSION")
          if echo "$RESPONSE" | grep -q "\"version\""; then
            echo "::warning::Crate $CRATE_NAME version $VERSION already exists on crates.io. Skipping publish."
          else
            echo "Publishing $CRATE_NAME version $VERSION to crates.io..."
            cargo publish --token ${{ secrets.CRATES_TOKEN }}
          fi
        
  docs:
    name: Build & Publish Docs
    runs-on: ubuntu-latest
    needs: prepare
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.build-docs)
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Build documentation
        run: cargo doc --no-deps --document-private-items
      
      - name: Prepare docs directory
        run: |
          # Create a redirect index.html in the root of the documentation
          echo '<!DOCTYPE html>
          <html>
            <head>
              <meta charset="utf-8">
              <meta http-equiv="refresh" content="0;url=orbit/index.html">
              <title>Redirecting to orbit documentation</title>
            </head>
            <body>
              <p>Redirecting to <a href="orbit/index.html">orbit documentation</a>...</p>
            </body>
          </html>' > ./target/doc/index.html
      
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ github.token }}
          publish_dir: ./target/doc
          
  artifacts:
    name: Build Artifacts
    runs-on: ${{ matrix.os }}
    needs: prepare
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.cross-platform-artifacts)
    strategy:
      matrix:
        include:
          # Linux builds
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux-x86_64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            name: linux-aarch64
          
          # Windows builds
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows-x86_64
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            name: windows-aarch64
          
          # macOS builds
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macos-x86_64
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macos-aarch64
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
      
      # Setup sccache for faster rust compilation
      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.3
          
      - name: Setup Cargo cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ matrix.target }}-
            
      - name: Configure Rust environment variables
        shell: bash
        run: |
          # Configure Rust environment variables for better performance
          echo "RUSTC_WRAPPER=sccache" >> $GITHUB_ENV
          echo "CARGO_INCREMENTAL=0" >> $GITHUB_ENV
          echo "SCCACHE_CACHE_SIZE=2G" >> $GITHUB_ENV
          echo "SCCACHE_DIR=$HOME/.cache/sccache" >> $GITHUB_ENV
          
          # Platform-specific optimizations
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            # On Linux, also use ramdisk if available
            if [ -d "/dev/shm" ]; then
              mkdir -p /dev/shm/sccache
              echo "SCCACHE_DIR=/dev/shm/sccache" >> $GITHUB_ENV
            fi
          fi
        
      - name: Setup cross-compilation environment for aarch64
        if: contains(matrix.target, 'aarch64')
        shell: bash
        run: |
          if [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
            echo "Setting up Linux ARM64 cross-compilation environment"
            
            # Install cross tool if not already cached
            if ! command -v cross &> /dev/null; then
              echo "Installing cross tool"
              cargo install cross --debug
            else
              echo "cross tool already installed, skipping"
            fi
            
            # Create .cargo directory for config
            mkdir -p .cargo
            
            # Using Cross.toml from repository root
            echo "Using Cross.toml from repository root"
            
            # Configure cargo for OpenSSL static linking
            echo '[build.env]' > .cargo/config.toml
            echo 'OPENSSL_STATIC = "1"' >> .cargo/config.toml
          elif [ "${{ matrix.os }}" = "macos-latest" ]; then
            echo "macOS runners on GitHub Actions have built-in support for ARM64"
          elif [ "${{ matrix.os }}" = "windows-latest" ]; then
            echo "Setting up Windows ARM64 cross-compilation environment"
            # No additional setup needed for Windows ARM64 as MSVC handles it
            # Just ensure the target is installed (which is done by the toolchain setup)
            echo "Using MSVC cross-compiler for Windows ARM64"
          fi
      
      - name: Create specialized Cargo.toml for aarch64
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        shell: bash
        run: |
          # Create a directory for the specialized build
          mkdir -p aarch64-build
          
          # Copy necessary workspace files (not just Cargo.toml)
          cp Cargo.toml aarch64-build/
          cp Cargo.lock aarch64-build/ || echo "No Cargo.lock found"
          
          # Create a complete source copy rather than using symbolic links
          # Docker container can't resolve symlinks properly
          echo "Creating complete source copy for aarch64 build"
          
          # Copy all source files
          mkdir -p aarch64-build/src
          cp -R src/* aarch64-build/src/
          
          # Copy examples directory if it exists
          if [ -d "examples" ]; then
            mkdir -p aarch64-build/examples
            cp -R examples/* aarch64-build/examples/
          fi
          
          # Verify lib.rs was copied correctly
          echo "Verifying lib.rs was copied:"
          ls -la aarch64-build/src/lib.rs || echo "ERROR: lib.rs not found in aarch64-build/src/"
          
          # Fix permissions to ensure files are accessible in container
          chmod -R a+rx aarch64-build
          
          cd aarch64-build
          
          # Modify the copied Cargo.toml to make reqwest optional
          # Make reqwest dependency optional
          sed -i 's/^reqwest = { version = "0.11", features = \["json"\] }$/reqwest = { version = "0.11", features = ["json"], optional = true }/g' Cargo.toml
          
          # Add http feature that includes reqwest
          if ! grep -q '\[features\]' Cargo.toml; then
            echo -e "\n[features]\nhttp = [\"dep:reqwest\"]" >> Cargo.toml
          else
            sed -i '/\[features\]/a http = [\"dep:reqwest\"]' Cargo.toml
          fi
          
          echo "Created specialized Cargo.toml for aarch64 build"
          cd ..
        
      - name: Install system dependencies (Linux x86_64 only)
        if: matrix.os == 'ubuntu-latest' && !contains(matrix.target, 'aarch64')
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libfontconfig1-dev \
            libfreetype6-dev
          
      - name: Build release
        shell: bash
        run: |
          if [ "${{ matrix.target }}" = "aarch64-unknown-linux-gnu" ]; then
            # Skip dependencies that require OpenSSL in cross-compilation
            
            # Build with cross using the specialized Cargo.toml
            cd aarch64-build
            
            # Copy Cross.toml with full path to ensure it's found
            cp -f "$(pwd)/../Cross.toml" ./Cross.toml
            
            # Verify the Cross.toml file exists and show its contents
            echo "Verifying Cross.toml file:"
            ls -la Cross.toml
            cat Cross.toml
            
            # Verify source files exist and have correct permissions
            echo "Verifying source files:"
            ls -la src/lib.rs
            # Ensure files are readable
            chmod -R a+r src
            
            # Create .cargo/config.toml with proper formatting
            mkdir -p .cargo
            echo '[build]' > .cargo/config.toml
            echo 'target-dir = "target"' >> .cargo/config.toml
            echo '' >> .cargo/config.toml
            echo "[target.${{ matrix.target }}]" >> .cargo/config.toml
            echo 'linker = "aarch64-linux-gnu-gcc"' >> .cargo/config.toml
            
            # Determine number of cores for parallel compilation
            JOBS=$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo 2)
            echo "Using $JOBS parallel jobs for compilation"
            
            # Run cross build with verbose output
            echo "Running cross build with target ${{ matrix.target }}"
            cross build --release --target ${{ matrix.target }} \
              --no-default-features \
              --features="skia,gl" \
              --verbose
            
            # Copy compiled artifacts back to the expected location
            mkdir -p ../target/${{ matrix.target }}/release/
            cp -r target/${{ matrix.target }}/release/* ../target/${{ matrix.target }}/release/
            cd ..
          else
            # Use standard cargo build for other targets
            cargo build --release --target ${{ matrix.target }}
          fi
          
      - name: Clean up aarch64 build directory
        if: matrix.target == 'aarch64-unknown-linux-gnu'
        shell: bash
        run: |
          # Remove the temporary build directory to save space
          rm -rf aarch64-build
        
      - name: Verify ARM64 build artifacts
        if: contains(matrix.target, 'aarch64')
        shell: bash
        run: |
          echo "Verifying ARM64 build artifacts for ${{ matrix.target }}"
          
          # List the contents of the target directory
          ls -la target/${{ matrix.target }}/release/
          
          # Get binary name from Cargo.toml
          BINARY_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].targets[] | select(.kind[] | contains("bin")) | .name' | head -n1)
          
          # Get package name
          PACKAGE_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].name')
          
          # Check if we have a binary
          if [ -n "$BINARY_NAME" ]; then
            if [ "${{ matrix.os }}" = "windows-latest" ]; then
              if [ ! -f "target/${{ matrix.target }}/release/${BINARY_NAME}.exe" ]; then
                echo "ERROR: Expected binary not found: target/${{ matrix.target }}/release/${BINARY_NAME}.exe"
                exit 1
              else
                echo "Binary verified: target/${{ matrix.target }}/release/${BINARY_NAME}.exe"
                # Get file size
                if [ "${{ matrix.os }}" = "windows-latest" ]; then
                  powershell -Command "'{0:N2} MB' -f ((Get-Item target/${{ matrix.target }}/release/${BINARY_NAME}.exe).length / 1MB)"
                else
                  ls -lh "target/${{ matrix.target }}/release/${BINARY_NAME}"
                fi
              fi
            else
              if [ ! -f "target/${{ matrix.target }}/release/${BINARY_NAME}" ]; then
                echo "ERROR: Expected binary not found: target/${{ matrix.target }}/release/${BINARY_NAME}"
                exit 1
              else
                echo "Binary verified: target/${{ matrix.target }}/release/${BINARY_NAME}"
                ls -lh "target/${{ matrix.target }}/release/${BINARY_NAME}"
              fi
            fi
          else
            # Check for library artifacts
            if [ -f "target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.rlib" ]; then
              echo "Library artifact verified: target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.rlib"
              ls -lh "target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.rlib"
            elif [ -f "target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.so" ]; then
              echo "Library artifact verified: target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.so"
              ls -lh "target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.so"
            elif [ -f "target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.dylib" ]; then
              echo "Library artifact verified: target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.dylib"
              ls -lh "target/${{ matrix.target }}/release/lib${PACKAGE_NAME}.dylib"
            elif [ -f "target/${{ matrix.target }}/release/${PACKAGE_NAME}.dll" ]; then
              echo "Library artifact verified: target/${{ matrix.target }}/release/${PACKAGE_NAME}.dll"
              ls -lh "target/${{ matrix.target }}/release/${PACKAGE_NAME}.dll"
            else
              echo "WARNING: No expected artifacts found for ${PACKAGE_NAME}"
              echo "Available files:"
              find "target/${{ matrix.target }}/release/" -type f -name "*${PACKAGE_NAME}*" | xargs ls -lh
            fi
          fi
        
      - name: Display sccache statistics
        shell: bash
        run: |
          echo "sccache statistics:"
          sccache --show-stats
        
      - name: Package artifacts
        shell: bash
        run: |
          # First check if there are any binary targets
          BINARY_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].targets[] | select(.kind[] | contains("bin")) | .name' | head -n1)
          
          # Get package name for creating artifacts even if no binary targets exist
          PACKAGE_NAME=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].name')
          PACKAGE_VERSION=$(cargo metadata --no-deps --format-version=1 | jq -r '.packages[0].version')
          TARGET=${{ matrix.target }}
          OS_NAME=${{ matrix.name }}
          
          # Create a dist directory with the target platform in the name to avoid conflicts
          mkdir -p "dist/${OS_NAME}"
          
          # Create a manifest file with build information
          cat > "dist/${OS_NAME}/manifest.txt" << 'EOL'
          Package: ${PACKAGE_NAME}
          Version: ${PACKAGE_VERSION}
          Target: ${TARGET}
          Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Git SHA: ${GITHUB_SHA}
          EOL
          
          if [ -n "$BINARY_NAME" ]; then
            # We have a binary target, copy it to dist with OS-specific name
            if [ "${{ matrix.os }}" = "windows-latest" ]; then
              cp "target/${TARGET}/release/${BINARY_NAME}.exe" "dist/${OS_NAME}/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.exe"
            else
              cp "target/${TARGET}/release/${BINARY_NAME}" "dist/${OS_NAME}/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}"
            fi
            echo "Binary target: ${BINARY_NAME}" >> "dist/${OS_NAME}/manifest.txt"
          else
            # No binary target found, create a package artifact instead
            echo "No binary target found. Creating package artifact for $PACKAGE_NAME v$PACKAGE_VERSION"
            echo "Library build - no binary targets found" >> "dist/${OS_NAME}/manifest.txt"
            
            # Create a directory for library files
            mkdir -p "dist/${OS_NAME}/lib"
            
            # Copy the compiled library artifacts if they exist with platform-specific names
            if [ -f "target/${TARGET}/release/lib${PACKAGE_NAME}.rlib" ]; then
              cp "target/${TARGET}/release/lib${PACKAGE_NAME}.rlib" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.rlib"
              echo "Library artifact: rlib" >> "dist/${OS_NAME}/manifest.txt"
            fi
            if [ -f "target/${TARGET}/release/lib${PACKAGE_NAME}.so" ]; then
              cp "target/${TARGET}/release/lib${PACKAGE_NAME}.so" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.so"
              echo "Library artifact: so" >> "dist/${OS_NAME}/manifest.txt"
            fi
            if [ -f "target/${TARGET}/release/lib${PACKAGE_NAME}.dylib" ]; then
              cp "target/${TARGET}/release/lib${PACKAGE_NAME}.dylib" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.dylib"
              echo "Library artifact: dylib" >> "dist/${OS_NAME}/manifest.txt"
            fi
            if [ -f "target/${TARGET}/release/${PACKAGE_NAME}.dll" ]; then
              cp "target/${TARGET}/release/${PACKAGE_NAME}.dll" "dist/${OS_NAME}/lib/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.dll"
              echo "Library artifact: dll" >> "dist/${OS_NAME}/manifest.txt"
            fi
          fi
          
          # Create a ZIP archive of the artifacts
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            powershell Compress-Archive -Path "dist/${OS_NAME}/*" -DestinationPath "dist/${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.zip"
          else
            (cd "dist/${OS_NAME}" && zip -r "../${PACKAGE_NAME}-${PACKAGE_VERSION}-${OS_NAME}.zip" .)
          fi
          
          # Keep both the directory and the ZIP file for flexibility
          echo "Created artifacts for ${PACKAGE_NAME} v${PACKAGE_VERSION} (${OS_NAME}):"
          find dist -type f | sort
      
      # Upload the zipped package directly
      - name: Upload zipped artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-zip
          path: dist/*.zip
          
      # Also upload the directory structure for compatibility
      - name: Upload directory artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-dir
          path: dist/${{ matrix.name }}/
  
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare, artifacts]
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || (github.event_name == 'workflow_dispatch' && inputs.cross-platform-artifacts)
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
      
      - name: List artifacts structure
        run: |
          echo "Listing downloaded artifacts structure:"
          find dist -type f | sort
          
      - name: Prepare files for release
        run: |
          # Create a flat directory structure for the release
          mkdir -p release_files
          for file in $(find dist -type f); do
            # Extract just the filename without directory path
            filename=$(basename "$file")
            # Copy to release_files dir with unique names in case of conflicts
            dir_name=$(dirname "$file" | sed -e 's|dist/||' | tr '/' '-')
            if [ "$dir_name" = "." ]; then
              cp "$file" "release_files/$filename"
            else
              cp "$file" "release_files/${dir_name}-${filename}"
            fi
          done
          echo "Files prepared for release:"
          ls -la release_files/
      
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: v${{ needs.prepare.outputs.version }}
          body: ${{ needs.prepare.outputs.changelog }}
          files: |
            release_files/*
            dist/*.zip
          draft: false
          prerelease: false
          fail_on_unmatched_files: false
